var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/index.ts
import MagicString from "magic-string";
import { parse, VERSION } from "svelte/compiler";

// src/helpers.ts
import { walk as estree_walk } from "estree-walker";

// src/load-svelte-config.ts
import { createRequire } from "module";
import { pathToFileURL } from "url";
import path from "path";
import fs from "fs";
var esmRequire;
var svelteConfigNames = ["svelte.config.js", "svelte.config.cjs", "svelte.config.mjs"];
async function dynamicImportDefault(filePath, timestamp) {
  return await import(filePath + "?t=" + timestamp).then((m) => m.default);
}
async function loadSvelteConfig(svelteConfigPath) {
  if (svelteConfigPath === false) {
    return;
  }
  const configFile = findConfigToLoad(svelteConfigPath);
  if (configFile) {
    let err;
    if (configFile.endsWith(".js") || configFile.endsWith(".mjs")) {
      try {
        const result = await dynamicImportDefault(
          pathToFileURL(configFile).href,
          fs.statSync(configFile).mtimeMs
        );
        if (result != null) {
          return {
            ...result,
            configFile
          };
        } else {
          throw new Error(`invalid export in ${configFile}`);
        }
      } catch (e) {
        console.error(`failed to import config ${configFile}`, e);
        err = e;
      }
    }
    if (!configFile.endsWith(".mjs")) {
      try {
        const _require = import.meta.url ? esmRequire ?? (esmRequire = createRequire(import.meta.url)) : __require;
        delete _require.cache[_require.resolve(configFile)];
        const result = _require(configFile);
        if (result != null) {
          return {
            ...result,
            configFile
          };
        } else {
          throw new Error(`invalid export in ${configFile}`);
        }
      } catch (e) {
        console.error(`failed to require config ${configFile}`, e);
        if (!err) {
          err = e;
        }
      }
    }
    throw err;
  }
}
function findConfigToLoad(svelteConfigPath) {
  const root = process.cwd();
  if (svelteConfigPath) {
    const absolutePath = path.isAbsolute(svelteConfigPath) ? svelteConfigPath : path.resolve(root, svelteConfigPath);
    if (!fs.existsSync(absolutePath)) {
      throw new Error(`failed to find svelte config file ${absolutePath}.`);
    }
    return absolutePath;
  } else {
    const existingKnownConfigFiles = svelteConfigNames.map((candidate) => path.resolve(root, candidate)).filter((file) => fs.existsSync(file));
    if (existingKnownConfigFiles.length === 0) {
      console.debug(`no svelte config found at ${root}`, void 0, "config");
      return;
    } else if (existingKnownConfigFiles.length > 1) {
      console.warn(
        `found more than one svelte config file, using ${existingKnownConfigFiles[0]}. you should only have one!`,
        existingKnownConfigFiles
      );
    }
    return existingKnownConfigFiles[0];
  }
}

// src/helpers.ts
function isAliasedAction(name, alias) {
  if (typeof alias === "string") {
    return name === alias;
  }
  return alias.includes(name);
}
var RUNES = [
  "$derived",
  "$effect",
  "$effect.active",
  "$effect.pre",
  "$effect.root",
  "$inspect",
  "$inspect.with",
  "$props",
  "$state",
  "$state.frozen"
];
async function isRuneMode(ast, options) {
  for (const element of ast.html.children ?? []) {
    if (element.type !== "Options" || element.name !== "svelte:options")
      continue;
    const attributes = element.attributes;
    for (const attr of attributes) {
      if (attr.name !== "runes")
        continue;
      if (typeof attr.value === "boolean") {
        return attr.value;
      }
      if (typeof attr.value[0].expression.value === "boolean") {
        return attr.value[0].expression.value;
      }
    }
  }
  const svelteConfig = await loadSvelteConfig(options?.svelteConfigPath);
  if (typeof svelteConfig?.compilerOptions?.runes === "boolean") {
    return svelteConfig.compilerOptions.runes;
  }
  let hasRunes = false;
  if (ast.module) {
    hasRunes = containsRunes(ast.module);
  }
  if (ast.instance) {
    hasRunes = hasRunes || containsRunes(ast.instance);
  }
  return hasRunes;
}
function containsRunes(script) {
  let containsRunes2 = false;
  walk(script, {
    enter(node) {
      if (containsRunes2) {
        this.skip();
        return;
      }
      if (node.type !== "CallExpression")
        return;
      const callExpression = node;
      const callee = callExpression.callee;
      if (callee.type === "Identifier") {
        containsRunes2 = RUNES.some((rune) => rune === callee.name);
      }
      if (callee.type === "MemberExpression") {
        if (callee.computed)
          return;
        if (callee.object.type !== "Identifier")
          return;
        if (callee.property.type !== "Identifier")
          return;
        const name = callee.object.name + "." + callee.property.name;
        containsRunes2 = RUNES.some((rune) => rune === name);
      }
    }
  });
  return containsRunes2;
}
function getMeltBuilderName(i) {
  return `__MELTUI_BUILDER_${i}__`;
}
function walk(ast, args) {
  return estree_walk(ast, args);
}

// src/traverse/Block.ts
function traverseBlock({ blockNode, config }) {
  if (blockNode.children === void 0)
    return;
  walk(blockNode.children, {
    enter(node) {
      if (node.type === "Action" && isAliasedAction(node.name, config.alias) && node.expression !== null) {
        handleActionNode({
          actionNode: node,
          blockNode,
          config
        });
        this.skip();
        return;
      }
      const returnedActions = traverse({ baseNode: node, config });
      for (const actionNode of returnedActions) {
        handleActionNode({
          actionNode,
          blockNode,
          config
        });
      }
      this.skip();
    }
  });
}
function handleActionNode({ config, actionNode, blockNode }) {
  const expression = actionNode.expression;
  if (expression.type !== "Identifier") {
    const expressionContent = config.content.substring(expression.start, expression.end);
    const blockContent = config.content.substring(blockNode.start, blockNode.end);
    const blockLines = blockContent.split("\n");
    const indent = blockLines.at(1)?.match(/\s*/);
    let firstChild = blockNode.children?.at(0);
    if (firstChild?.type === "Text") {
      firstChild = blockNode.children?.at(1);
    }
    let lastConst;
    for (const child of blockNode.children ?? []) {
      if (child.type === "ConstTag")
        lastConst = child;
    }
    const pos = lastConst?.end ?? firstChild?.start;
    const constIdentifier = getMeltBuilderName(config.builderCount++);
    if (!pos)
      throw Error("This is unreachable");
    const constTag = lastConst ? `
${indent}{@const ${constIdentifier} = ${expressionContent}}` : `{@const ${constIdentifier} = ${expressionContent}}
${indent}`;
    config.builders.push({
      identifierName: constIdentifier,
      startPos: actionNode.start,
      endPos: actionNode.end
    });
    config.markup.prependRight(pos, constTag);
  } else {
    config.builders.push({
      identifierName: expression.name,
      startPos: actionNode.start,
      endPos: actionNode.end
    });
  }
}

// src/traverse/EachBlock.ts
function traverseEachBlock({ eachBlockNode, config }) {
  if (eachBlockNode.type !== "EachBlock")
    throw Error("This node is not an EachBlock");
  traverseBlock({
    blockNode: eachBlockNode,
    config
  });
}

// src/traverse/AwaitBlock.ts
function traverseAwaitBlock({ awaitBlockNode, config }) {
  if (awaitBlockNode.type !== "AwaitBlock")
    throw Error("This node is not an AwaitBlock");
  traverseBlock({
    blockNode: awaitBlockNode.then,
    config
  });
  traverseBlock({
    blockNode: awaitBlockNode.catch,
    config
  });
}

// src/traverse/ComponentBlock.ts
function traverseComponentBlock({ compBlockNode, config }) {
  if (compBlockNode.type !== "InlineComponent" && compBlockNode.type !== "SlotTemplate")
    throw Error("This node is not an InlineComponent or a SlotTemplate");
  traverseBlock({
    blockNode: compBlockNode,
    config
  });
}

// src/traverse/index.ts
function traverse({ baseNode, config }) {
  const actions = [];
  walk(baseNode, {
    enter(node) {
      if (node.type === "EachBlock") {
        traverseEachBlock({ eachBlockNode: node, config });
        this.skip();
      }
      if ((node.type === "InlineComponent" || node.type === "SlotTemplate") && node.children && node.children.length > 0) {
        traverseComponentBlock({ compBlockNode: node, config });
        this.skip();
      }
      if (node.type === "AwaitBlock") {
        traverseAwaitBlock({ awaitBlockNode: node, config });
        this.skip();
      }
      if (node.type === "Action" && isAliasedAction(node.name, config.alias) && node.expression !== null) {
        actions.push(node);
        this.skip();
      }
    }
  });
  return actions;
}

// src/sequence.ts
import { preprocess } from "svelte/compiler";
function sequence(preprocessors) {
  return {
    async markup({ content, filename }) {
      let code = content;
      let map;
      let attributes;
      let toString;
      const dependencies = [];
      for (const pp of preprocessors) {
        const processed = await preprocess(code, pp, { filename });
        if (processed && processed.dependencies) {
          dependencies.push(...processed.dependencies);
        }
        code = processed ? processed.code : code;
        map = processed.map ?? map;
        attributes = processed.attributes ?? attributes;
        toString = processed.toString ?? toString;
      }
      return {
        code,
        dependencies,
        map,
        attributes,
        toString
      };
    }
  };
}

// src/index.ts
function preprocessMeltUI(options) {
  const isSvelte5 = VERSION.startsWith("5");
  return {
    name: "MeltUI Preprocess",
    markup: async ({ content, filename }) => {
      const config = {
        alias: options?.alias ?? "melt",
        markup: new MagicString(content, { filename }),
        builders: [],
        builderCount: 0,
        content
      };
      let scriptContentNode;
      const ast = parse(content, { css: false, filename });
      const runesMode = isSvelte5 && await isRuneMode(ast, options);
      if (ast.instance) {
        walk(ast.instance, {
          enter(node) {
            if (node.type === "Script" && node.context === "default") {
              scriptContentNode = node.content;
            }
          }
        });
      }
      const leftOverActions = traverse({ baseNode: ast.html, config });
      leftOverActions.forEach((action) => {
        handleTopLevelAction({ actionNode: action, config });
      });
      let identifiersToInsert = "";
      for (const builder of config.builders) {
        let identifier = "";
        if ("identifierName" in builder) {
          identifier = builder.identifierName;
        } else {
          identifier = getMeltBuilderName(config.builderCount++);
          if (runesMode) {
            identifiersToInsert += `	let ${identifier} = $derived(${builder.expression.contents});
`;
          } else {
            identifiersToInsert += `	$: ${identifier} = ${builder.expression.contents};
`;
          }
        }
        const attributes = `{...${identifier}} use:${identifier}.action`;
        config.markup.overwrite(builder.startPos, builder.endPos, attributes, {
          storeName: true
        });
      }
      if (identifiersToInsert) {
        if (scriptContentNode) {
          config.markup.appendRight(scriptContentNode.end, "\n" + identifiersToInsert);
        } else {
          config.markup.prepend("<script>\n" + identifiersToInsert + "\n</script>\n");
        }
      }
      return {
        code: config.markup.toString()
      };
    }
  };
}
function handleTopLevelAction(args) {
  const { actionNode, config } = args;
  let identifierName;
  const expression = actionNode.expression;
  if (expression.type === "Identifier") {
    identifierName = expression.name;
    config.builders.push({
      identifierName,
      startPos: actionNode.start,
      endPos: actionNode.end
    });
  } else {
    config.builders.push({
      expression: {
        startPos: expression.start,
        endPos: expression.end,
        contents: config.content.substring(expression.start, expression.end)
      },
      startPos: actionNode.start,
      endPos: actionNode.end
    });
  }
}
export {
  preprocessMeltUI,
  sequence
};
//# sourceMappingURL=index.js.map