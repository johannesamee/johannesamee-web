{"version":3,"sources":["../src/index.ts","../src/helpers.ts","../src/load-svelte-config.ts","../src/traverse/Block.ts","../src/traverse/EachBlock.ts","../src/traverse/AwaitBlock.ts","../src/traverse/ComponentBlock.ts","../src/traverse/index.ts","../src/sequence.ts"],"sourcesContent":["import MagicString from 'magic-string';\nimport { parse, type PreprocessorGroup, VERSION } from 'svelte/compiler';\nimport { getMeltBuilderName, isRuneMode, walk } from './helpers.js';\nimport { traverse } from './traverse/index.js';\n\nimport type { TemplateNode } from 'svelte/types/compiler/interfaces';\nimport type { Config, Node } from './types.js';\n\nexport * from './sequence.js';\n\nexport type PreprocessOptions = {\n\t/**\n\t * For aliasing the name of the `melt` action.\n\t *\n\t * When configured, the PP will __only__ process action names\n\t * that are passed to this field.\n\t *\n\t * @example\n\t * ```ts\n\t * // ONLY process actions named `_melt`\n\t * preprocessMeltUI({ alias: [\"_melt\"] })\n\t *\n\t * // process actions named `_melt` or `melt`\n\t * preprocessMeltUI({ alias: [\"melt\", \"_melt\"] })\n\t *\n\t * ```\n\t *\n\t * @default \"melt\"\n\t */\n\talias?: string | string[];\n\t/**\n\t * Path to a svelte config file, either absolute or relative to `process.cwd()`.\n\t *\n\t * Set to `false` to ignore the svelte config file.\n\t */\n\tsvelteConfigPath?: string | false;\n};\n\n/**\n * A preprocessor for Melt UI.\n *\n * Intelligently replaces all instances of `use:melt={$builder}` with the correct spread syntax,\n * providing a sleeker developer experience.\n *\n * Simply add it to the end of your array of preprocessors.\n * @example\n * ```js\n * // svelte.config.js\n * import { preprocessMeltUI } from '@melt-ui/pp';\n *\n * const config = {\n * \t// ... other svelte config options\n * \tpreprocess: [\n * \t\t// ... other preprocessors\n * \t\tpreprocessMeltUI() // add to the end!\n * \t]\n * \t// ...\n * };\n * ```\n */\nexport function preprocessMeltUI(options?: PreprocessOptions): PreprocessorGroup {\n\tconst isSvelte5 = VERSION.startsWith('5');\n\treturn {\n\t\tname: 'MeltUI Preprocess',\n\t\tmarkup: async ({ content, filename }) => {\n\t\t\tconst config: Config = {\n\t\t\t\talias: options?.alias ?? 'melt',\n\t\t\t\tmarkup: new MagicString(content, { filename }),\n\t\t\t\tbuilders: [],\n\t\t\t\tbuilderCount: 0,\n\t\t\t\tcontent,\n\t\t\t};\n\n\t\t\tlet scriptContentNode: { start: number; end: number } | undefined;\n\t\t\tconst ast = parse(content, { css: false, filename });\n\t\t\tconst runesMode = isSvelte5 && (await isRuneMode(ast, options));\n\n\t\t\t// Grab the Script node so we can inject any hoisted expressions later\n\t\t\tif (ast.instance) {\n\t\t\t\twalk(ast.instance, {\n\t\t\t\t\tenter(node) {\n\t\t\t\t\t\tif (node.type === 'Script' && node.context === 'default') {\n\t\t\t\t\t\t\tscriptContentNode = node.content as { start: number; end: number };\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst leftOverActions = traverse({ baseNode: ast.html, config });\n\n\t\t\t// Any action that couldn't find a home within a scoped block will\n\t\t\t// bubble up to the top, indicating that these actions need\n\t\t\t// their expressions hoisted.\n\t\t\tleftOverActions.forEach((action) => {\n\t\t\t\thandleTopLevelAction({ actionNode: action, config });\n\t\t\t});\n\n\t\t\t// Build the identifiers to later inject into the script tag\n\t\t\tlet identifiersToInsert = '';\n\t\t\tfor (const builder of config.builders) {\n\t\t\t\tlet identifier = '';\n\t\t\t\tif ('identifierName' in builder) {\n\t\t\t\t\t// if the user just passed in an identifier, just use that\n\t\t\t\t\tidentifier = builder.identifierName;\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise, we'll take the expression and hoist it into the script node\n\t\t\t\t\tidentifier = getMeltBuilderName(config.builderCount++);\n\t\t\t\t\tif (runesMode) {\n\t\t\t\t\t\tidentifiersToInsert += `\\tlet ${identifier} = $derived(${builder.expression.contents});\\n`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidentifiersToInsert += `\\t$: ${identifier} = ${builder.expression.contents};\\n`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst attributes = `{...${identifier}} use:${identifier}.action`;\n\n\t\t\t\t// replace the `use:melt={...}` with the attributes\n\t\t\t\tconfig.markup.overwrite(builder.startPos, builder.endPos, attributes, {\n\t\t\t\t\tstoreName: true,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// inject the hoisted expressions into the script node\n\t\t\tif (identifiersToInsert) {\n\t\t\t\tif (scriptContentNode) {\n\t\t\t\t\t// insert the new identifiers into the end of the script tag\n\t\t\t\t\tconfig.markup.appendRight(scriptContentNode.end, '\\n' + identifiersToInsert);\n\t\t\t\t} else {\n\t\t\t\t\t// incase they don't already have a script tag...\n\t\t\t\t\tconfig.markup.prepend('<script>\\n' + identifiersToInsert + '\\n</script>\\n');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcode: config.markup.toString(),\n\t\t\t};\n\t\t},\n\t};\n}\n\ntype HandleTopLevelActionArgs = {\n\tactionNode: TemplateNode;\n\tconfig: Config;\n};\n/**\n * Constructs the Builder and adds it to its list.\n */\nfunction handleTopLevelAction(args: HandleTopLevelActionArgs) {\n\tconst { actionNode, config } = args;\n\tlet identifierName: string | undefined;\n\tconst expression = actionNode.expression as Node;\n\n\tif (expression.type === 'Identifier') {\n\t\t// only an identifier was passed\n\t\t// i.e. use:melt={$builder}\n\t\tidentifierName = expression.name;\n\t\tconfig.builders.push({\n\t\t\tidentifierName,\n\t\t\tstartPos: actionNode.start,\n\t\t\tendPos: actionNode.end,\n\t\t});\n\t} else {\n\t\t// any other expression type...\n\t\t// i.e. use:melt={$builder({ arg1: '', arg2: '' })}\n\t\tconfig.builders.push({\n\t\t\texpression: {\n\t\t\t\tstartPos: expression.start,\n\t\t\t\tendPos: expression.end,\n\t\t\t\tcontents: config.content.substring(expression.start, expression.end),\n\t\t\t},\n\t\t\tstartPos: actionNode.start,\n\t\t\tendPos: actionNode.end,\n\t\t});\n\t}\n}\n","import { walk as estree_walk } from 'estree-walker';\nimport { loadSvelteConfig } from './load-svelte-config.js';\n\nimport type { Ast, TemplateNode } from 'svelte/types/compiler/interfaces';\nimport type { CallExpression } from 'estree';\nimport type { Node } from './types.js';\nimport type { PreprocessOptions } from './index.js';\n\nexport function isAliasedAction(name: string, alias: string | string[]): boolean {\n\tif (typeof alias === 'string') {\n\t\treturn name === alias;\n\t}\n\treturn alias.includes(name);\n}\n\nconst RUNES = [\n\t'$derived',\n\t'$effect',\n\t'$effect.active',\n\t'$effect.pre',\n\t'$effect.root',\n\t'$inspect',\n\t'$inspect.with',\n\t'$props',\n\t'$state',\n\t'$state.frozen',\n];\n\n/**\n * There are 3 ways to determine if a component is in 'runes mode':\n * \t1. If `<svelte:options runes={true} />` is set\n * \t2. If `svelte-config.compilerOptions.runes` === `true`\n * \t3. If a rune is present in the component (`$state`, `$derived`, `$effect`, etc.)\n */\nexport async function isRuneMode(\n\tast: Ast,\n\toptions?: PreprocessOptions\n): Promise<boolean> {\n\t// check if the component has `<svelte:options runes />`\n\tfor (const element of ast.html.children ?? []) {\n\t\tif (element.type !== 'Options' || element.name !== 'svelte:options') continue;\n\n\t\tconst attributes = element.attributes;\n\t\tfor (const attr of attributes) {\n\t\t\tif (attr.name !== 'runes') continue;\n\t\t\t// `<svelte:options runes />`\n\t\t\tif (typeof attr.value === 'boolean') {\n\t\t\t\treturn attr.value;\n\t\t\t}\n\t\t\t// `<svelte:options runes={false} />` or `<svelte:options runes={true} />`\n\t\t\tif (typeof attr.value[0].expression.value === 'boolean') {\n\t\t\t\treturn attr.value[0].expression.value;\n\t\t\t}\n\t\t}\n\t}\n\n\t// `svelte-config.compilerOptions.runes`\n\tconst svelteConfig = await loadSvelteConfig(options?.svelteConfigPath);\n\tif (typeof svelteConfig?.compilerOptions?.runes === 'boolean') {\n\t\treturn svelteConfig.compilerOptions.runes;\n\t}\n\n\t// a rune is present in the component\n\tlet hasRunes = false;\n\tif (ast.module) {\n\t\thasRunes = containsRunes(ast.module);\n\t}\n\n\tif (ast.instance) {\n\t\thasRunes = hasRunes || containsRunes(ast.instance);\n\t}\n\n\treturn hasRunes;\n}\ntype Script = NonNullable<Ast['instance']>;\nfunction containsRunes(script: Script): boolean {\n\tlet containsRunes = false;\n\n\twalk(script, {\n\t\tenter(node) {\n\t\t\t// already found a rune, don't need to check the rest\n\t\t\tif (containsRunes) {\n\t\t\t\tthis.skip();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (node.type !== 'CallExpression') return;\n\t\t\tconst callExpression = node as unknown as CallExpression;\n\n\t\t\t// $inspect(item)\n\t\t\tconst callee = callExpression.callee;\n\t\t\tif (callee.type === 'Identifier') {\n\t\t\t\tcontainsRunes = RUNES.some((rune) => rune === callee.name);\n\t\t\t}\n\t\t\t// $inspect.with(item)\n\t\t\tif (callee.type === 'MemberExpression') {\n\t\t\t\tif (callee.computed) return;\n\t\t\t\tif (callee.object.type !== 'Identifier') return;\n\t\t\t\tif (callee.property.type !== 'Identifier') return;\n\n\t\t\t\tconst name = callee.object.name + '.' + callee.property.name;\n\t\t\t\tcontainsRunes = RUNES.some((rune) => rune === name);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn containsRunes;\n}\n\nexport function getMeltBuilderName(i: number) {\n\treturn `__MELTUI_BUILDER_${i}__`;\n}\n\n// excuse the mess...\ntype Enter = Parameters<typeof estree_walk>[1]['enter'];\ntype EnterParams = Parameters<NonNullable<Enter>>;\ntype Leave = Parameters<typeof estree_walk>[1]['leave'];\ntype WalkerContext = {\n\tskip: () => void;\n\tremove: () => void;\n\treplace: (node: Node) => void;\n};\ntype WalkerArgs<Node extends TemplateNode> = {\n\tenter?: (\n\t\tthis: WalkerContext,\n\t\tnode: Node,\n\t\tparent: Node | null,\n\t\tkey: EnterParams[2],\n\t\tindex: EnterParams[3]\n\t) => void;\n\tleave?: Leave;\n};\n/**\n * Enhances the param types of the estree-walker's `walk` function\n * as it doesn't want to accept Svelte's provided `TemplateNode` type.\n */\nexport function walk<AST extends TemplateNode | Array<Node>, Node extends TemplateNode>(\n\tast: AST,\n\targs: WalkerArgs<Node>\n) {\n\t// @ts-expect-error do this once so i don't have to keep adding these ignores\n\treturn estree_walk(ast, args);\n}\n","// Originally sourced and modified from https://github.com/sveltejs/vite-plugin-svelte/blob/main/packages/vite-plugin-svelte/src/utils/load-svelte-config.js\n\nimport { createRequire } from 'node:module';\nimport { pathToFileURL } from 'node:url';\nimport path from 'node:path';\nimport fs from 'node:fs';\n\n// used to require cjs config in esm.\n// NOTE dynamic import() cjs technically works, but timestamp query cache bust\n// have no effect, likely because it has another internal cache?\nlet esmRequire: NodeRequire;\n\nconst svelteConfigNames = ['svelte.config.js', 'svelte.config.cjs', 'svelte.config.mjs'];\n\nasync function dynamicImportDefault(filePath: string, timestamp: number) {\n\treturn await import(filePath + '?t=' + timestamp).then((m) => m.default);\n}\n\ntype SvelteConfig = {\n\tcompilerOptions?: { runes?: boolean };\n};\n\nexport async function loadSvelteConfig(\n\tsvelteConfigPath?: string | false\n): Promise<SvelteConfig | undefined> {\n\tif (svelteConfigPath === false) {\n\t\treturn;\n\t}\n\tconst configFile = findConfigToLoad(svelteConfigPath);\n\tif (configFile) {\n\t\tlet err;\n\t\t// try to use dynamic import for svelte.config.js first\n\t\tif (configFile.endsWith('.js') || configFile.endsWith('.mjs')) {\n\t\t\ttry {\n\t\t\t\tconst result = await dynamicImportDefault(\n\t\t\t\t\tpathToFileURL(configFile).href,\n\t\t\t\t\tfs.statSync(configFile).mtimeMs\n\t\t\t\t);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\tconfigFile,\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`invalid export in ${configFile}`);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(`failed to import config ${configFile}`, e);\n\t\t\t\terr = e;\n\t\t\t}\n\t\t}\n\t\t// cjs or error with dynamic import\n\t\tif (!configFile.endsWith('.mjs')) {\n\t\t\ttry {\n\t\t\t\t// identify which require function to use (esm and cjs mode)\n\t\t\t\tconst _require = import.meta.url\n\t\t\t\t\t? esmRequire ?? (esmRequire = createRequire(import.meta.url))\n\t\t\t\t\t: require;\n\n\t\t\t\t// avoid loading cached version on reload\n\t\t\t\tdelete _require.cache[_require.resolve(configFile)];\n\t\t\t\tconst result = _require(configFile);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\tconfigFile,\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`invalid export in ${configFile}`);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(`failed to require config ${configFile}`, e);\n\t\t\t\tif (!err) {\n\t\t\t\t\terr = e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// failed to load existing config file\n\t\tthrow err;\n\t}\n}\n\nfunction findConfigToLoad(svelteConfigPath?: string): string | undefined {\n\tconst root = process.cwd();\n\tif (svelteConfigPath) {\n\t\tconst absolutePath = path.isAbsolute(svelteConfigPath)\n\t\t\t? svelteConfigPath\n\t\t\t: path.resolve(root, svelteConfigPath);\n\t\tif (!fs.existsSync(absolutePath)) {\n\t\t\tthrow new Error(`failed to find svelte config file ${absolutePath}.`);\n\t\t}\n\t\treturn absolutePath;\n\t} else {\n\t\tconst existingKnownConfigFiles = svelteConfigNames\n\t\t\t.map((candidate) => path.resolve(root, candidate))\n\t\t\t.filter((file) => fs.existsSync(file));\n\t\tif (existingKnownConfigFiles.length === 0) {\n\t\t\tconsole.debug(`no svelte config found at ${root}`, undefined, 'config');\n\t\t\treturn;\n\t\t} else if (existingKnownConfigFiles.length > 1) {\n\t\t\tconsole.warn(\n\t\t\t\t`found more than one svelte config file, using ${existingKnownConfigFiles[0]}. you should only have one!`,\n\t\t\t\texistingKnownConfigFiles\n\t\t\t);\n\t\t}\n\t\treturn existingKnownConfigFiles[0];\n\t}\n}\n","import { getMeltBuilderName, isAliasedAction, walk } from '../helpers.js';\nimport { traverse } from './index.js';\n\nimport type { TemplateNode } from 'svelte/types/compiler/interfaces';\nimport type { Config, Node } from '../types.js';\n\ntype BlockArgs = {\n\tblockNode: TemplateNode;\n\tconfig: Config;\n};\n\n/**\n * Traverses any given block and checks if there are any identifiers\n * that exist in it's child `melt` action's expression.\n *\n * If there are, we'll inject an `{@const}` block into the provided block\n * with it's corresponding identifiers.\n */\nexport function traverseBlock({ blockNode, config }: BlockArgs) {\n\tif (blockNode.children === undefined) return;\n\n\t// walk the children to determine if the block's provided identifiers are\n\t// being used in the melt action's expression\n\twalk(blockNode.children, {\n\t\tenter(node) {\n\t\t\tif (\n\t\t\t\tnode.type === 'Action' &&\n\t\t\t\tisAliasedAction(node.name, config.alias) &&\n\t\t\t\tnode.expression !== null // assigned to something\n\t\t\t) {\n\t\t\t\thandleActionNode({\n\t\t\t\t\tactionNode: node,\n\t\t\t\t\tblockNode,\n\t\t\t\t\tconfig,\n\t\t\t\t});\n\n\t\t\t\t// we don't have to walk the Action's children\n\t\t\t\tthis.skip();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// if it's anything else, walk again\n\t\t\tconst returnedActions = traverse({ baseNode: node, config });\n\n\t\t\tfor (const actionNode of returnedActions) {\n\t\t\t\thandleActionNode({\n\t\t\t\t\tactionNode,\n\t\t\t\t\tblockNode,\n\t\t\t\t\tconfig,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// only want to walk over the direct children, so we'll skip the rest\n\t\t\tthis.skip();\n\t\t},\n\t});\n}\n\ntype HandleActionNodeArgs = {\n\tblockNode: TemplateNode;\n\tactionNode: TemplateNode;\n\tconfig: Config;\n};\n\n/**\n * Injects the `{@const}` tag as a child of the provided block\n * node if the expression is anything but an `Identifier`.\n */\nfunction handleActionNode({ config, actionNode, blockNode }: HandleActionNodeArgs) {\n\tconst expression = actionNode.expression as Node;\n\n\t// any other expression type...\n\t// i.e. use:melt={$builder({ arg1: '', arg2: '' })}\n\tif (expression.type !== 'Identifier') {\n\t\tconst expressionContent = config.content.substring(expression.start, expression.end);\n\n\t\t// extract the indent of the block such that the indentation of the injected\n\t\t// {@const} tag is in line with the rest of the block\n\t\tconst blockContent = config.content.substring(blockNode.start, blockNode.end);\n\t\tconst blockLines = blockContent.split('\\n');\n\t\tconst indent = blockLines.at(1)?.match(/\\s*/);\n\n\t\t// a weird quirk with Await and Component blocks where the first child\n\t\t// is a Text node, so we'll ignore them and take the 2nd child instead\n\t\tlet firstChild = blockNode.children?.at(0);\n\t\tif (firstChild?.type === 'Text') {\n\t\t\tfirstChild = blockNode.children?.at(1);\n\t\t}\n\n\t\t// checks if there are any existing `{@const}` tags. if there are, we want to\n\t\t// append the injected block at the end\n\t\tlet lastConst: TemplateNode | undefined;\n\t\tfor (const child of blockNode.children ?? []) {\n\t\t\tif (child.type === 'ConstTag') lastConst = child;\n\t\t}\n\n\t\t// convert this into a {@const} block\n\t\tconst pos = lastConst?.end ?? firstChild?.start;\n\t\tconst constIdentifier = getMeltBuilderName(config.builderCount++);\n\t\tif (!pos) throw Error('This is unreachable');\n\n\t\t// we'll add the indent and new line depending on where we're injecting it\n\t\tconst constTag = lastConst\n\t\t\t? `\\n${indent}{@const ${constIdentifier} = ${expressionContent}}`\n\t\t\t: `{@const ${constIdentifier} = ${expressionContent}}\\n${indent}`;\n\n\t\tconfig.builders.push({\n\t\t\tidentifierName: constIdentifier,\n\t\t\tstartPos: actionNode.start,\n\t\t\tendPos: actionNode.end,\n\t\t});\n\n\t\tconfig.markup.prependRight(pos, constTag);\n\t} else {\n\t\t// if it's just an identifier, add it to the list of builders so that it can\n\t\t// later be transformed into the correct syntax\n\t\t// i.e. use:melt={$builder}\n\t\tconfig.builders.push({\n\t\t\tidentifierName: expression.name,\n\t\t\tstartPos: actionNode.start,\n\t\t\tendPos: actionNode.end,\n\t\t});\n\t}\n}\n","import { traverseBlock } from './Block.js';\n\nimport type { TemplateNode } from 'svelte/types/compiler/interfaces';\nimport type { Config } from '../types.js';\n\ntype TraverseEachBlockArgs = {\n\teachBlockNode: TemplateNode;\n\tconfig: Config;\n};\nexport function traverseEachBlock({ eachBlockNode, config }: TraverseEachBlockArgs) {\n\tif (eachBlockNode.type !== 'EachBlock') throw Error('This node is not an EachBlock');\n\n\t// determine if those identifiers are being used in the melt action's expression\n\ttraverseBlock({\n\t\tblockNode: eachBlockNode,\n\t\tconfig,\n\t});\n}\n","import { traverseBlock } from './Block.js';\n\nimport type { TemplateNode } from 'svelte/types/compiler/interfaces';\nimport type { Config } from '../types.js';\n\ntype TraverseAwaitBlockArgs = {\n\tawaitBlockNode: TemplateNode;\n\tconfig: Config;\n};\nexport function traverseAwaitBlock({ awaitBlockNode, config }: TraverseAwaitBlockArgs) {\n\tif (awaitBlockNode.type !== 'AwaitBlock') throw Error('This node is not an AwaitBlock');\n\n\t/* determine if those identifiers are being used in the melt action's expression */\n\n\t// then block\n\ttraverseBlock({\n\t\tblockNode: awaitBlockNode.then,\n\t\tconfig,\n\t});\n\n\t// catch block\n\ttraverseBlock({\n\t\tblockNode: awaitBlockNode.catch,\n\t\tconfig,\n\t});\n}\n","import { traverseBlock } from './Block.js';\n\nimport type { TemplateNode } from 'svelte/types/compiler/interfaces';\nimport type { Config } from '../types.js';\n\ntype TraverseEachBlockArgs = {\n\tcompBlockNode: TemplateNode;\n\tconfig: Config;\n};\nexport function traverseComponentBlock({ compBlockNode, config }: TraverseEachBlockArgs) {\n\tif (compBlockNode.type !== 'InlineComponent' && compBlockNode.type !== 'SlotTemplate')\n\t\tthrow Error('This node is not an InlineComponent or a SlotTemplate');\n\n\t// determine if those identifiers are scoped to this block\n\ttraverseBlock({\n\t\tblockNode: compBlockNode,\n\t\tconfig,\n\t});\n}\n","import { traverseEachBlock } from './EachBlock.js';\nimport { traverseAwaitBlock } from './AwaitBlock.js';\nimport { traverseComponentBlock } from './ComponentBlock.js';\nimport { isAliasedAction, walk } from '../helpers.js';\n\nimport type { TemplateNode } from 'svelte/types/compiler/interfaces';\nimport type { Config } from '../types.js';\n\ntype TraverseArgs = {\n\tbaseNode: TemplateNode;\n\tconfig: Config;\n};\nexport function traverse({ baseNode, config }: TraverseArgs) {\n\tconst actions: TemplateNode[] = [];\n\n\twalk(baseNode, {\n\t\tenter(node) {\n\t\t\t// if there's an each block that contains an expression,\n\t\t\t// add a {@const identifier = expression}\n\t\t\tif (node.type === 'EachBlock') {\n\t\t\t\ttraverseEachBlock({ eachBlockNode: node, config });\n\n\t\t\t\t// don't need to traverse the rest of the Each Block\n\t\t\t\tthis.skip();\n\t\t\t}\n\n\t\t\t// components with a let:identifier\n\t\t\tif (\n\t\t\t\t(node.type === 'InlineComponent' || node.type === 'SlotTemplate') &&\n\t\t\t\tnode.children &&\n\t\t\t\tnode.children.length > 0\n\t\t\t) {\n\t\t\t\ttraverseComponentBlock({ compBlockNode: node, config });\n\n\t\t\t\t// don't need to traverse the rest of the Component Block\n\t\t\t\tthis.skip();\n\t\t\t}\n\n\t\t\t// {#await} blocks\n\t\t\tif (node.type === 'AwaitBlock') {\n\t\t\t\t// check identifiers in the then and catch block, if present\n\t\t\t\ttraverseAwaitBlock({ awaitBlockNode: node, config });\n\n\t\t\t\t// don't need to traverse the rest of the Await Block\n\t\t\t\tthis.skip();\n\t\t\t}\n\n\t\t\t// top level Actions\n\t\t\tif (\n\t\t\t\tnode.type === 'Action' &&\n\t\t\t\tisAliasedAction(node.name, config.alias) &&\n\t\t\t\tnode.expression !== null // assigned to something\n\t\t\t) {\n\t\t\t\tactions.push(node);\n\n\t\t\t\t// we don't have to walk the Action's children\n\t\t\t\tthis.skip();\n\t\t\t}\n\t\t},\n\t});\n\n\t// return all the leftover actions\n\treturn actions;\n}\n","// Originally sourced and modified from https://github.com/pchynoweth/svelte-sequential-preprocessor\n\nimport { preprocess } from 'svelte/compiler';\nimport { PreprocessorGroup, Processed } from 'svelte/types/compiler/preprocess';\n\n/**\n * A Svelte preprocessor that wraps other preprocessors and forces them to run sequentially.\n *\n * @example\n * ```js\n * // svelte.config.js\n * import { preprocessMeltUI, sequence } from '@melt-ui/pp';\n *\n * const config = {\n * \t// ... other svelte config options\n * \tpreprocess: sequence([\n * \t\t// ... other preprocessors (e.g. `vitePreprocess()`)\n * \t\tpreprocessMeltUI()\n * \t])\n * \t// ...\n * };\n * ```\n */\nexport function sequence(preprocessors: PreprocessorGroup[]): PreprocessorGroup {\n\treturn {\n\t\tasync markup({ content, filename }): Promise<Processed> {\n\t\t\tlet code = content;\n\t\t\tlet map: Processed['map'];\n\t\t\tlet attributes: Processed['attributes'];\n\t\t\tlet toString: Processed['toString'];\n\t\t\tconst dependencies: Processed['dependencies'] = [];\n\n\t\t\tfor (const pp of preprocessors) {\n\t\t\t\tconst processed = await preprocess(code, pp, { filename });\n\t\t\t\tif (processed && processed.dependencies) {\n\t\t\t\t\tdependencies.push(...processed.dependencies);\n\t\t\t\t}\n\t\t\t\tcode = processed ? processed.code : code;\n\t\t\t\tmap = processed.map ?? map;\n\t\t\t\tattributes = processed.attributes ?? attributes;\n\t\t\t\ttoString = processed.toString ?? toString;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcode,\n\t\t\t\tdependencies,\n\t\t\t\tmap,\n\t\t\t\tattributes,\n\t\t\t\ttoString,\n\t\t\t};\n\t\t},\n\t};\n}\n"],"mappings":";;;;;;;;;AAAA,OAAO,iBAAiB;AACxB,SAAS,OAA+B,eAAe;;;ACDvD,SAAS,QAAQ,mBAAmB;;;ACEpC,SAAS,qBAAqB;AAC9B,SAAS,qBAAqB;AAC9B,OAAO,UAAU;AACjB,OAAO,QAAQ;AAKf,IAAI;AAEJ,IAAM,oBAAoB,CAAC,oBAAoB,qBAAqB,mBAAmB;AAEvF,eAAe,qBAAqB,UAAkB,WAAmB;AACxE,SAAO,MAAM,OAAO,WAAW,QAAQ,WAAW,KAAK,CAAC,MAAM,EAAE,OAAO;AACxE;AAMA,eAAsB,iBACrB,kBACoC;AACpC,MAAI,qBAAqB,OAAO;AAC/B;AAAA,EACD;AACA,QAAM,aAAa,iBAAiB,gBAAgB;AACpD,MAAI,YAAY;AACf,QAAI;AAEJ,QAAI,WAAW,SAAS,KAAK,KAAK,WAAW,SAAS,MAAM,GAAG;AAC9D,UAAI;AACH,cAAM,SAAS,MAAM;AAAA,UACpB,cAAc,UAAU,EAAE;AAAA,UAC1B,GAAG,SAAS,UAAU,EAAE;AAAA,QACzB;AACA,YAAI,UAAU,MAAM;AACnB,iBAAO;AAAA,YACN,GAAG;AAAA,YACH;AAAA,UACD;AAAA,QACD,OAAO;AACN,gBAAM,IAAI,MAAM,qBAAqB,UAAU,EAAE;AAAA,QAClD;AAAA,MACD,SAAS,GAAG;AACX,gBAAQ,MAAM,2BAA2B,UAAU,IAAI,CAAC;AACxD,cAAM;AAAA,MACP;AAAA,IACD;AAEA,QAAI,CAAC,WAAW,SAAS,MAAM,GAAG;AACjC,UAAI;AAEH,cAAM,WAAW,YAAY,MAC1B,eAAe,aAAa,cAAc,YAAY,GAAG,KACzD;AAGH,eAAO,SAAS,MAAM,SAAS,QAAQ,UAAU,CAAC;AAClD,cAAM,SAAS,SAAS,UAAU;AAClC,YAAI,UAAU,MAAM;AACnB,iBAAO;AAAA,YACN,GAAG;AAAA,YACH;AAAA,UACD;AAAA,QACD,OAAO;AACN,gBAAM,IAAI,MAAM,qBAAqB,UAAU,EAAE;AAAA,QAClD;AAAA,MACD,SAAS,GAAG;AACX,gBAAQ,MAAM,4BAA4B,UAAU,IAAI,CAAC;AACzD,YAAI,CAAC,KAAK;AACT,gBAAM;AAAA,QACP;AAAA,MACD;AAAA,IACD;AAEA,UAAM;AAAA,EACP;AACD;AAEA,SAAS,iBAAiB,kBAA+C;AACxE,QAAM,OAAO,QAAQ,IAAI;AACzB,MAAI,kBAAkB;AACrB,UAAM,eAAe,KAAK,WAAW,gBAAgB,IAClD,mBACA,KAAK,QAAQ,MAAM,gBAAgB;AACtC,QAAI,CAAC,GAAG,WAAW,YAAY,GAAG;AACjC,YAAM,IAAI,MAAM,qCAAqC,YAAY,GAAG;AAAA,IACrE;AACA,WAAO;AAAA,EACR,OAAO;AACN,UAAM,2BAA2B,kBAC/B,IAAI,CAAC,cAAc,KAAK,QAAQ,MAAM,SAAS,CAAC,EAChD,OAAO,CAAC,SAAS,GAAG,WAAW,IAAI,CAAC;AACtC,QAAI,yBAAyB,WAAW,GAAG;AAC1C,cAAQ,MAAM,6BAA6B,IAAI,IAAI,QAAW,QAAQ;AACtE;AAAA,IACD,WAAW,yBAAyB,SAAS,GAAG;AAC/C,cAAQ;AAAA,QACP,iDAAiD,yBAAyB,CAAC,CAAC;AAAA,QAC5E;AAAA,MACD;AAAA,IACD;AACA,WAAO,yBAAyB,CAAC;AAAA,EAClC;AACD;;;ADnGO,SAAS,gBAAgB,MAAc,OAAmC;AAChF,MAAI,OAAO,UAAU,UAAU;AAC9B,WAAO,SAAS;AAAA,EACjB;AACA,SAAO,MAAM,SAAS,IAAI;AAC3B;AAEA,IAAM,QAAQ;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD;AAQA,eAAsB,WACrB,KACA,SACmB;AAEnB,aAAW,WAAW,IAAI,KAAK,YAAY,CAAC,GAAG;AAC9C,QAAI,QAAQ,SAAS,aAAa,QAAQ,SAAS;AAAkB;AAErE,UAAM,aAAa,QAAQ;AAC3B,eAAW,QAAQ,YAAY;AAC9B,UAAI,KAAK,SAAS;AAAS;AAE3B,UAAI,OAAO,KAAK,UAAU,WAAW;AACpC,eAAO,KAAK;AAAA,MACb;AAEA,UAAI,OAAO,KAAK,MAAM,CAAC,EAAE,WAAW,UAAU,WAAW;AACxD,eAAO,KAAK,MAAM,CAAC,EAAE,WAAW;AAAA,MACjC;AAAA,IACD;AAAA,EACD;AAGA,QAAM,eAAe,MAAM,iBAAiB,SAAS,gBAAgB;AACrE,MAAI,OAAO,cAAc,iBAAiB,UAAU,WAAW;AAC9D,WAAO,aAAa,gBAAgB;AAAA,EACrC;AAGA,MAAI,WAAW;AACf,MAAI,IAAI,QAAQ;AACf,eAAW,cAAc,IAAI,MAAM;AAAA,EACpC;AAEA,MAAI,IAAI,UAAU;AACjB,eAAW,YAAY,cAAc,IAAI,QAAQ;AAAA,EAClD;AAEA,SAAO;AACR;AAEA,SAAS,cAAc,QAAyB;AAC/C,MAAIA,iBAAgB;AAEpB,OAAK,QAAQ;AAAA,IACZ,MAAM,MAAM;AAEX,UAAIA,gBAAe;AAClB,aAAK,KAAK;AACV;AAAA,MACD;AAEA,UAAI,KAAK,SAAS;AAAkB;AACpC,YAAM,iBAAiB;AAGvB,YAAM,SAAS,eAAe;AAC9B,UAAI,OAAO,SAAS,cAAc;AACjC,QAAAA,iBAAgB,MAAM,KAAK,CAAC,SAAS,SAAS,OAAO,IAAI;AAAA,MAC1D;AAEA,UAAI,OAAO,SAAS,oBAAoB;AACvC,YAAI,OAAO;AAAU;AACrB,YAAI,OAAO,OAAO,SAAS;AAAc;AACzC,YAAI,OAAO,SAAS,SAAS;AAAc;AAE3C,cAAM,OAAO,OAAO,OAAO,OAAO,MAAM,OAAO,SAAS;AACxD,QAAAA,iBAAgB,MAAM,KAAK,CAAC,SAAS,SAAS,IAAI;AAAA,MACnD;AAAA,IACD;AAAA,EACD,CAAC;AAED,SAAOA;AACR;AAEO,SAAS,mBAAmB,GAAW;AAC7C,SAAO,oBAAoB,CAAC;AAC7B;AAyBO,SAAS,KACf,KACA,MACC;AAED,SAAO,YAAY,KAAK,IAAI;AAC7B;;;AE5HO,SAAS,cAAc,EAAE,WAAW,OAAO,GAAc;AAC/D,MAAI,UAAU,aAAa;AAAW;AAItC,OAAK,UAAU,UAAU;AAAA,IACxB,MAAM,MAAM;AACX,UACC,KAAK,SAAS,YACd,gBAAgB,KAAK,MAAM,OAAO,KAAK,KACvC,KAAK,eAAe,MACnB;AACD,yBAAiB;AAAA,UAChB,YAAY;AAAA,UACZ;AAAA,UACA;AAAA,QACD,CAAC;AAGD,aAAK,KAAK;AACV;AAAA,MACD;AAGA,YAAM,kBAAkB,SAAS,EAAE,UAAU,MAAM,OAAO,CAAC;AAE3D,iBAAW,cAAc,iBAAiB;AACzC,yBAAiB;AAAA,UAChB;AAAA,UACA;AAAA,UACA;AAAA,QACD,CAAC;AAAA,MACF;AAGA,WAAK,KAAK;AAAA,IACX;AAAA,EACD,CAAC;AACF;AAYA,SAAS,iBAAiB,EAAE,QAAQ,YAAY,UAAU,GAAyB;AAClF,QAAM,aAAa,WAAW;AAI9B,MAAI,WAAW,SAAS,cAAc;AACrC,UAAM,oBAAoB,OAAO,QAAQ,UAAU,WAAW,OAAO,WAAW,GAAG;AAInF,UAAM,eAAe,OAAO,QAAQ,UAAU,UAAU,OAAO,UAAU,GAAG;AAC5E,UAAM,aAAa,aAAa,MAAM,IAAI;AAC1C,UAAM,SAAS,WAAW,GAAG,CAAC,GAAG,MAAM,KAAK;AAI5C,QAAI,aAAa,UAAU,UAAU,GAAG,CAAC;AACzC,QAAI,YAAY,SAAS,QAAQ;AAChC,mBAAa,UAAU,UAAU,GAAG,CAAC;AAAA,IACtC;AAIA,QAAI;AACJ,eAAW,SAAS,UAAU,YAAY,CAAC,GAAG;AAC7C,UAAI,MAAM,SAAS;AAAY,oBAAY;AAAA,IAC5C;AAGA,UAAM,MAAM,WAAW,OAAO,YAAY;AAC1C,UAAM,kBAAkB,mBAAmB,OAAO,cAAc;AAChE,QAAI,CAAC;AAAK,YAAM,MAAM,qBAAqB;AAG3C,UAAM,WAAW,YACd;AAAA,EAAK,MAAM,WAAW,eAAe,MAAM,iBAAiB,MAC5D,WAAW,eAAe,MAAM,iBAAiB;AAAA,EAAM,MAAM;AAEhE,WAAO,SAAS,KAAK;AAAA,MACpB,gBAAgB;AAAA,MAChB,UAAU,WAAW;AAAA,MACrB,QAAQ,WAAW;AAAA,IACpB,CAAC;AAED,WAAO,OAAO,aAAa,KAAK,QAAQ;AAAA,EACzC,OAAO;AAIN,WAAO,SAAS,KAAK;AAAA,MACpB,gBAAgB,WAAW;AAAA,MAC3B,UAAU,WAAW;AAAA,MACrB,QAAQ,WAAW;AAAA,IACpB,CAAC;AAAA,EACF;AACD;;;AClHO,SAAS,kBAAkB,EAAE,eAAe,OAAO,GAA0B;AACnF,MAAI,cAAc,SAAS;AAAa,UAAM,MAAM,+BAA+B;AAGnF,gBAAc;AAAA,IACb,WAAW;AAAA,IACX;AAAA,EACD,CAAC;AACF;;;ACRO,SAAS,mBAAmB,EAAE,gBAAgB,OAAO,GAA2B;AACtF,MAAI,eAAe,SAAS;AAAc,UAAM,MAAM,gCAAgC;AAKtF,gBAAc;AAAA,IACb,WAAW,eAAe;AAAA,IAC1B;AAAA,EACD,CAAC;AAGD,gBAAc;AAAA,IACb,WAAW,eAAe;AAAA,IAC1B;AAAA,EACD,CAAC;AACF;;;AChBO,SAAS,uBAAuB,EAAE,eAAe,OAAO,GAA0B;AACxF,MAAI,cAAc,SAAS,qBAAqB,cAAc,SAAS;AACtE,UAAM,MAAM,uDAAuD;AAGpE,gBAAc;AAAA,IACb,WAAW;AAAA,IACX;AAAA,EACD,CAAC;AACF;;;ACNO,SAAS,SAAS,EAAE,UAAU,OAAO,GAAiB;AAC5D,QAAM,UAA0B,CAAC;AAEjC,OAAK,UAAU;AAAA,IACd,MAAM,MAAM;AAGX,UAAI,KAAK,SAAS,aAAa;AAC9B,0BAAkB,EAAE,eAAe,MAAM,OAAO,CAAC;AAGjD,aAAK,KAAK;AAAA,MACX;AAGA,WACE,KAAK,SAAS,qBAAqB,KAAK,SAAS,mBAClD,KAAK,YACL,KAAK,SAAS,SAAS,GACtB;AACD,+BAAuB,EAAE,eAAe,MAAM,OAAO,CAAC;AAGtD,aAAK,KAAK;AAAA,MACX;AAGA,UAAI,KAAK,SAAS,cAAc;AAE/B,2BAAmB,EAAE,gBAAgB,MAAM,OAAO,CAAC;AAGnD,aAAK,KAAK;AAAA,MACX;AAGA,UACC,KAAK,SAAS,YACd,gBAAgB,KAAK,MAAM,OAAO,KAAK,KACvC,KAAK,eAAe,MACnB;AACD,gBAAQ,KAAK,IAAI;AAGjB,aAAK,KAAK;AAAA,MACX;AAAA,IACD;AAAA,EACD,CAAC;AAGD,SAAO;AACR;;;AC7DA,SAAS,kBAAkB;AAqBpB,SAAS,SAAS,eAAuD;AAC/E,SAAO;AAAA,IACN,MAAM,OAAO,EAAE,SAAS,SAAS,GAAuB;AACvD,UAAI,OAAO;AACX,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,YAAM,eAA0C,CAAC;AAEjD,iBAAW,MAAM,eAAe;AAC/B,cAAM,YAAY,MAAM,WAAW,MAAM,IAAI,EAAE,SAAS,CAAC;AACzD,YAAI,aAAa,UAAU,cAAc;AACxC,uBAAa,KAAK,GAAG,UAAU,YAAY;AAAA,QAC5C;AACA,eAAO,YAAY,UAAU,OAAO;AACpC,cAAM,UAAU,OAAO;AACvB,qBAAa,UAAU,cAAc;AACrC,mBAAW,UAAU,YAAY;AAAA,MAClC;AAEA,aAAO;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;;;ARQO,SAAS,iBAAiB,SAAgD;AAChF,QAAM,YAAY,QAAQ,WAAW,GAAG;AACxC,SAAO;AAAA,IACN,MAAM;AAAA,IACN,QAAQ,OAAO,EAAE,SAAS,SAAS,MAAM;AACxC,YAAM,SAAiB;AAAA,QACtB,OAAO,SAAS,SAAS;AAAA,QACzB,QAAQ,IAAI,YAAY,SAAS,EAAE,SAAS,CAAC;AAAA,QAC7C,UAAU,CAAC;AAAA,QACX,cAAc;AAAA,QACd;AAAA,MACD;AAEA,UAAI;AACJ,YAAM,MAAM,MAAM,SAAS,EAAE,KAAK,OAAO,SAAS,CAAC;AACnD,YAAM,YAAY,aAAc,MAAM,WAAW,KAAK,OAAO;AAG7D,UAAI,IAAI,UAAU;AACjB,aAAK,IAAI,UAAU;AAAA,UAClB,MAAM,MAAM;AACX,gBAAI,KAAK,SAAS,YAAY,KAAK,YAAY,WAAW;AACzD,kCAAoB,KAAK;AAAA,YAC1B;AAAA,UACD;AAAA,QACD,CAAC;AAAA,MACF;AAEA,YAAM,kBAAkB,SAAS,EAAE,UAAU,IAAI,MAAM,OAAO,CAAC;AAK/D,sBAAgB,QAAQ,CAAC,WAAW;AACnC,6BAAqB,EAAE,YAAY,QAAQ,OAAO,CAAC;AAAA,MACpD,CAAC;AAGD,UAAI,sBAAsB;AAC1B,iBAAW,WAAW,OAAO,UAAU;AACtC,YAAI,aAAa;AACjB,YAAI,oBAAoB,SAAS;AAEhC,uBAAa,QAAQ;AAAA,QACtB,OAAO;AAEN,uBAAa,mBAAmB,OAAO,cAAc;AACrD,cAAI,WAAW;AACd,mCAAuB,QAAS,UAAU,eAAe,QAAQ,WAAW,QAAQ;AAAA;AAAA,UACrF,OAAO;AACN,mCAAuB,OAAQ,UAAU,MAAM,QAAQ,WAAW,QAAQ;AAAA;AAAA,UAC3E;AAAA,QACD;AAEA,cAAM,aAAa,OAAO,UAAU,SAAS,UAAU;AAGvD,eAAO,OAAO,UAAU,QAAQ,UAAU,QAAQ,QAAQ,YAAY;AAAA,UACrE,WAAW;AAAA,QACZ,CAAC;AAAA,MACF;AAGA,UAAI,qBAAqB;AACxB,YAAI,mBAAmB;AAEtB,iBAAO,OAAO,YAAY,kBAAkB,KAAK,OAAO,mBAAmB;AAAA,QAC5E,OAAO;AAEN,iBAAO,OAAO,QAAQ,eAAe,sBAAsB,eAAe;AAAA,QAC3E;AAAA,MACD;AAEA,aAAO;AAAA,QACN,MAAM,OAAO,OAAO,SAAS;AAAA,MAC9B;AAAA,IACD;AAAA,EACD;AACD;AASA,SAAS,qBAAqB,MAAgC;AAC7D,QAAM,EAAE,YAAY,OAAO,IAAI;AAC/B,MAAI;AACJ,QAAM,aAAa,WAAW;AAE9B,MAAI,WAAW,SAAS,cAAc;AAGrC,qBAAiB,WAAW;AAC5B,WAAO,SAAS,KAAK;AAAA,MACpB;AAAA,MACA,UAAU,WAAW;AAAA,MACrB,QAAQ,WAAW;AAAA,IACpB,CAAC;AAAA,EACF,OAAO;AAGN,WAAO,SAAS,KAAK;AAAA,MACpB,YAAY;AAAA,QACX,UAAU,WAAW;AAAA,QACrB,QAAQ,WAAW;AAAA,QACnB,UAAU,OAAO,QAAQ,UAAU,WAAW,OAAO,WAAW,GAAG;AAAA,MACpE;AAAA,MACA,UAAU,WAAW;AAAA,MACrB,QAAQ,WAAW;AAAA,IACpB,CAAC;AAAA,EACF;AACD;","names":["containsRunes"]}